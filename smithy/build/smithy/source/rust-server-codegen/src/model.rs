// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone,
    ::std::cmp::Eq,
    ::std::cmp::Ord,
    ::std::cmp::PartialEq,
    ::std::cmp::PartialOrd,
    ::std::fmt::Debug,
    ::std::hash::Hash,
)]
pub enum ErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    Database,
    #[allow(missing_docs)] // documentation missing in model
    Infer,
    #[allow(missing_docs)] // documentation missing in model
    Network,
    #[allow(missing_docs)] // documentation missing in model
    Unknown,
}
/// See [`ErrorCode`](crate::model::ErrorCode).
pub mod error_code {
    #[derive(Debug, PartialEq)]
    pub struct ConstraintViolation(pub(crate) ::std::string::String);
}
impl ::std::convert::TryFrom<&str> for ErrorCode {
    type Error = crate::model::error_code::ConstraintViolation;
    fn try_from(
        s: &str,
    ) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
        match s {
            "database" => Ok(ErrorCode::Database),
            "infer" => Ok(ErrorCode::Infer),
            "network" => Ok(ErrorCode::Network),
            "unknown" => Ok(ErrorCode::Unknown),
            _ => Err(crate::model::error_code::ConstraintViolation(s.to_owned())),
        }
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ErrorCode {
    type Error = crate::model::error_code::ConstraintViolation;
    fn try_from(
        s: ::std::string::String,
    ) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error>
    {
        s.as_str().try_into()
    }
}
impl std::str::FromStr for ErrorCode {
    type Err = crate::model::error_code::ConstraintViolation;
    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
        Self::try_from(s)
    }
}
impl ErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCode::Database => "database",
            ErrorCode::Infer => "infer",
            ErrorCode::Network => "network",
            ErrorCode::Unknown => "unknown",
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["database", "infer", "network", "unknown"]
    }
}
impl ::std::convert::AsRef<str> for ErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl crate::constrained::Constrained for ErrorCode {
    type Unconstrained = ::std::string::String;
}

impl ::std::convert::From<::std::string::String>
    for crate::constrained::MaybeConstrained<crate::model::ErrorCode>
{
    fn from(value: ::std::string::String) -> Self {
        Self::Unconstrained(value)
    }
}

/// Describes one specific validation failure for an input member.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ValidationExceptionField {
    /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
    pub path: ::std::string::String,
    /// A detailed description of the validation failure.
    pub message: ::std::string::String,
}
impl ValidationExceptionField {
    /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
    pub fn path(&self) -> &str {
        use std::ops::Deref;
        self.path.deref()
    }
    /// A detailed description of the validation failure.
    pub fn message(&self) -> &str {
        use std::ops::Deref;
        self.message.deref()
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct DatasetField {
    #[allow(missing_docs)] // documentation missing in model
    pub name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub r#type: ::std::string::String,
}
impl DatasetField {
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn r#type(&self) -> &str {
        use std::ops::Deref;
        self.r#type.deref()
    }
}
impl DatasetField {
    /// Creates a new builder-style object to manufacture [`DatasetField`](crate::model::DatasetField).
    pub fn builder() -> crate::model::dataset_field::Builder {
        crate::model::dataset_field::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct DatasetInfo {
    #[allow(missing_docs)] // documentation missing in model
    pub name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub fields: ::std::vec::Vec<crate::model::DatasetField>,
}
impl DatasetInfo {
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn fields(&self) -> &[crate::model::DatasetField] {
        use std::ops::Deref;
        self.fields.deref()
    }
}
impl DatasetInfo {
    /// Creates a new builder-style object to manufacture [`DatasetInfo`](crate::model::DatasetInfo).
    pub fn builder() -> crate::model::dataset_info::Builder {
        crate::model::dataset_info::Builder::default()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
///
pub mod validation_exception_field {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `path` was not provided but it is required when building `ValidationExceptionField`.
        MissingPath,
        /// `message` was not provided but it is required when building `ValidationExceptionField`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingPath => write!(f, "`path` was not provided but it is required when building `ValidationExceptionField`"),
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `ValidationExceptionField`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::model::ValidationExceptionField {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: ::std::option::Option<::std::string::String>,
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
        pub fn path(mut self, input: ::std::string::String) -> Self {
            self.path = Some(input);
            self
        }
        /// A detailed description of the validation failure.
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        ///
        /// The builder fails to construct a [`ValidationExceptionField`](crate::model::ValidationExceptionField) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::ValidationExceptionField, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::model::ValidationExceptionField, ConstraintViolation> {
            Ok(crate::model::ValidationExceptionField {
                path: self.path.ok_or(ConstraintViolation::MissingPath)?,
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`DatasetField`](crate::model::DatasetField).
///
pub mod dataset_field {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `name` was not provided but it is required when building `DatasetField`.
        MissingName,
        /// `r#type` was not provided but it is required when building `DatasetField`.
        MissingType,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingName => write!(
                    f,
                    "`name` was not provided but it is required when building `DatasetField`"
                ),
                ConstraintViolation::MissingType => write!(
                    f,
                    "`r#type` was not provided but it is required when building `DatasetField`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::model::DatasetField {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`DatasetField`](crate::model::DatasetField).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: ::std::option::Option<::std::string::String>,
        pub(crate) r#type: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: ::std::string::String) -> Self {
            self.name = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn r#type(mut self, input: ::std::string::String) -> Self {
            self.r#type = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`DatasetField`](crate::model::DatasetField).
        ///
        /// The builder fails to construct a [`DatasetField`](crate::model::DatasetField) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::DatasetField, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::model::DatasetField, ConstraintViolation> {
            Ok(crate::model::DatasetField {
                name: self.name.ok_or(ConstraintViolation::MissingName)?,
                r#type: self.r#type.ok_or(ConstraintViolation::MissingType)?,
            })
        }
    }
}
/// See [`DatasetInfo`](crate::model::DatasetInfo).
///
pub mod dataset_info {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `name` was not provided but it is required when building `DatasetInfo`.
        MissingName,
        /// `fields` was not provided but it is required when building `DatasetInfo`.
        MissingFields,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingName => write!(
                    f,
                    "`name` was not provided but it is required when building `DatasetInfo`"
                ),
                ConstraintViolation::MissingFields => write!(
                    f,
                    "`fields` was not provided but it is required when building `DatasetInfo`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::model::DatasetInfo {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`DatasetInfo`](crate::model::DatasetInfo).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: ::std::option::Option<::std::string::String>,
        pub(crate) fields: ::std::option::Option<::std::vec::Vec<crate::model::DatasetField>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: ::std::string::String) -> Self {
            self.name = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn fields(mut self, input: ::std::vec::Vec<crate::model::DatasetField>) -> Self {
            self.fields = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`DatasetInfo`](crate::model::DatasetInfo).
        ///
        /// The builder fails to construct a [`DatasetInfo`](crate::model::DatasetInfo) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::DatasetInfo, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::model::DatasetInfo, ConstraintViolation> {
            Ok(crate::model::DatasetInfo {
                name: self.name.ok_or(ConstraintViolation::MissingName)?,
                fields: self.fields.ok_or(ConstraintViolation::MissingFields)?,
            })
        }
    }
}
