// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

const CONTENT_TYPE_QUERYDATASET: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`QueryDatasetInput`](crate::input::QueryDatasetInput) using modelled bindings.
    pub struct QueryDatasetInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::QueryDatasetInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for QueryDatasetInputFuture {
    type Output = Result<
        crate::input::QueryDatasetInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::QueryDatasetInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = QueryDatasetInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_QUERYDATASET,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }

            crate::protocol_serde::shape_query_dataset::de_query_dataset_http_request(request)
                .await
                .map_err(Into::into)
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        QueryDatasetInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::QueryDatasetOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_query_dataset::ser_query_dataset_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::QueryDatasetError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_query_dataset::ser_query_dataset_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_GETDATASET: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`GetDatasetInput`](crate::input::GetDatasetInput) using modelled bindings.
    pub struct GetDatasetInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::GetDatasetInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for GetDatasetInputFuture {
    type Output = Result<
        crate::input::GetDatasetInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::GetDatasetInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = GetDatasetInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_GETDATASET,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }

            crate::protocol_serde::shape_get_dataset::de_get_dataset_http_request(request)
                .await
                .map_err(Into::into)
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        GetDatasetInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::GetDatasetOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_get_dataset::ser_get_dataset_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::GetDatasetError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_get_dataset::ser_get_dataset_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_CREATEDATASET: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`CreateDatasetInput`](crate::input::CreateDatasetInput) using modelled bindings.
    pub struct CreateDatasetInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::CreateDatasetInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for CreateDatasetInputFuture {
    type Output = Result<
        crate::input::CreateDatasetInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::CreateDatasetInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = CreateDatasetInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_CREATEDATASET,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }

            crate::protocol_serde::shape_create_dataset::de_create_dataset_http_request(request)
                .await
                .map_err(Into::into)
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        CreateDatasetInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::CreateDatasetOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_create_dataset::ser_create_dataset_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::CreateDatasetError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_create_dataset::ser_create_dataset_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_LISTDATASET: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`ListDatasetInput`](crate::input::ListDatasetInput) using modelled bindings.
    pub struct ListDatasetInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::ListDatasetInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for ListDatasetInputFuture {
    type Output = Result<
        crate::input::ListDatasetInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::ListDatasetInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = ListDatasetInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_LISTDATASET,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }

            crate::protocol_serde::shape_list_dataset::de_list_dataset_http_request(request)
                .await
                .map_err(Into::into)
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        ListDatasetInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::ListDatasetOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_list_dataset::ser_list_dataset_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::ListDatasetError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_list_dataset::ser_list_dataset_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_SIGNIN: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`SigninInput`](crate::input::SigninInput) using modelled bindings.
    pub struct SigninInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::SigninInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for SigninInputFuture {
    type Output = Result<
        crate::input::SigninInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::SigninInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = SigninInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_SIGNIN,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }

            crate::protocol_serde::shape_signin::de_signin_http_request(request)
                .await
                .map_err(Into::into)
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        SigninInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::SigninOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_signin::ser_signin_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::SigninError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_signin::ser_signin_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_HEALTHCHECK: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`HealthCheckInput`](crate::input::HealthCheckInput) using modelled bindings.
    pub struct HealthCheckInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::HealthCheckInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for HealthCheckInputFuture {
    type Output = Result<
        crate::input::HealthCheckInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::HealthCheckInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = HealthCheckInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_HEALTHCHECK,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }

            crate::protocol_serde::shape_health_check::de_health_check_http_request(request)
                .await
                .map_err(Into::into)
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        HealthCheckInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::HealthCheckOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_health_check::ser_health_check_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::HealthCheckError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_health_check::ser_health_check_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
