// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `Signin` operation.
/// Each variant represents an error that can occur for the `Signin` operation.
#[derive(::std::fmt::Debug)]
pub enum SigninError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    /// Unauthorized error.
    UnauthorizedError(crate::error::UnauthorizedError),
    /// Forbidden error.
    ForbiddenError(crate::error::ForbiddenError),
    /// Throttling error.
    ThrottlingError(crate::error::ThrottlingError),
}
impl ::std::fmt::Display for SigninError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            SigninError::ValidationException(_inner) => _inner.fmt(f),
            SigninError::UnauthorizedError(_inner) => _inner.fmt(f),
            SigninError::ForbiddenError(_inner) => _inner.fmt(f),
            SigninError::ThrottlingError(_inner) => _inner.fmt(f),
        }
    }
}
impl SigninError {
    /// Returns `true` if the error kind is `SigninError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, SigninError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `SigninError::UnauthorizedError`.
    pub fn is_unauthorized_error(&self) -> bool {
        matches!(&self, SigninError::UnauthorizedError(_))
    }
    /// Returns `true` if the error kind is `SigninError::ForbiddenError`.
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self, SigninError::ForbiddenError(_))
    }
    /// Returns `true` if the error kind is `SigninError::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self, SigninError::ThrottlingError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            SigninError::ValidationException(_inner) => _inner.name(),
            SigninError::UnauthorizedError(_inner) => _inner.name(),
            SigninError::ForbiddenError(_inner) => _inner.name(),
            SigninError::ThrottlingError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for SigninError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            SigninError::ValidationException(_inner) => Some(_inner),
            SigninError::UnauthorizedError(_inner) => Some(_inner),
            SigninError::ForbiddenError(_inner) => Some(_inner),
            SigninError::ThrottlingError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::SigninError {
    fn from(variant: crate::error::ValidationException) -> crate::error::SigninError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::UnauthorizedError> for crate::error::SigninError {
    fn from(variant: crate::error::UnauthorizedError) -> crate::error::SigninError {
        Self::UnauthorizedError(variant)
    }
}
impl ::std::convert::From<crate::error::ForbiddenError> for crate::error::SigninError {
    fn from(variant: crate::error::ForbiddenError) -> crate::error::SigninError {
        Self::ForbiddenError(variant)
    }
}
impl ::std::convert::From<crate::error::ThrottlingError> for crate::error::SigninError {
    fn from(variant: crate::error::ThrottlingError) -> crate::error::SigninError {
        Self::ThrottlingError(variant)
    }
}

/// Throttling error.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ThrottlingError {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl ThrottlingError {
    /// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
    pub fn retryable_error_kind(&self) -> ::aws_smithy_types::retry::ErrorKind {
        ::aws_smithy_types::retry::ErrorKind::ClientError
    }
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ThrottlingError"
    }
}
impl ::std::fmt::Display for ThrottlingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ThrottlingError")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ThrottlingError {}
impl ThrottlingError {
    /// Creates a new builder-style object to manufacture [`ThrottlingError`](crate::error::ThrottlingError).
    pub fn builder() -> crate::error::throttling_error::Builder {
        crate::error::throttling_error::Builder::default()
    }
}

/// Forbidden error.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ForbiddenError {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl ForbiddenError {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ForbiddenError"
    }
}
impl ::std::fmt::Display for ForbiddenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ForbiddenError")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ForbiddenError {}
impl ForbiddenError {
    /// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError).
    pub fn builder() -> crate::error::forbidden_error::Builder {
        crate::error::forbidden_error::Builder::default()
    }
}

/// Unauthorized error.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct UnauthorizedError {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl UnauthorizedError {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "UnauthorizedError"
    }
}
impl ::std::fmt::Display for UnauthorizedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "UnauthorizedError")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for UnauthorizedError {}
impl UnauthorizedError {
    /// Creates a new builder-style object to manufacture [`UnauthorizedError`](crate::error::UnauthorizedError).
    pub fn builder() -> crate::error::unauthorized_error::Builder {
        crate::error::unauthorized_error::Builder::default()
    }
}

/// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ValidationException {
    /// A summary of the validation failure.
    pub message: ::std::string::String,
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub field_list: ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
}
impl ValidationException {
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub fn field_list(&self) -> ::std::option::Option<&[crate::model::ValidationExceptionField]> {
        self.field_list.as_deref()
    }
}
impl ValidationException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ValidationException"
    }
}
impl ::std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ValidationException")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ValidationException {}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// Error type for the `EchoMessage` operation.
/// Each variant represents an error that can occur for the `EchoMessage` operation.
#[derive(::std::fmt::Debug)]
pub enum EchoMessageError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl ::std::fmt::Display for EchoMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            EchoMessageError::ValidationException(_inner) => _inner.fmt(f),
        }
    }
}
impl EchoMessageError {
    /// Returns `true` if the error kind is `EchoMessageError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, EchoMessageError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            EchoMessageError::ValidationException(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for EchoMessageError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            EchoMessageError::ValidationException(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::EchoMessageError {
    fn from(variant: crate::error::ValidationException) -> crate::error::EchoMessageError {
        Self::ValidationException(variant)
    }
}
/// See [`ThrottlingError`](crate::error::ThrottlingError).
///
pub mod throttling_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ThrottlingError`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(
                    f,
                    "`message` was not provided but it is required when building `ThrottlingError`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ThrottlingError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ThrottlingError`](crate::error::ThrottlingError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingError`](crate::error::ThrottlingError).
        ///
        /// The builder fails to construct a [`ThrottlingError`](crate::error::ThrottlingError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::ThrottlingError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ThrottlingError, ConstraintViolation> {
            Ok(crate::error::ThrottlingError {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`ForbiddenError`](crate::error::ForbiddenError).
///
pub mod forbidden_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ForbiddenError`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(
                    f,
                    "`message` was not provided but it is required when building `ForbiddenError`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ForbiddenError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ForbiddenError`](crate::error::ForbiddenError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError).
        ///
        /// The builder fails to construct a [`ForbiddenError`](crate::error::ForbiddenError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::ForbiddenError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ForbiddenError, ConstraintViolation> {
            Ok(crate::error::ForbiddenError {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`UnauthorizedError`](crate::error::UnauthorizedError).
///
pub mod unauthorized_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `UnauthorizedError`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `UnauthorizedError`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::UnauthorizedError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`UnauthorizedError`](crate::error::UnauthorizedError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedError`](crate::error::UnauthorizedError).
        ///
        /// The builder fails to construct a [`UnauthorizedError`](crate::error::UnauthorizedError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::UnauthorizedError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::UnauthorizedError, ConstraintViolation> {
            Ok(crate::error::UnauthorizedError {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`ValidationException`](crate::error::ValidationException).
///
pub mod validation_exception {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ValidationException`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `ValidationException`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ValidationException {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
        pub(crate) field_list:
            ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
    }
    impl Builder {
        /// A summary of the validation failure.
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
        pub fn field_list(
            mut self,
            input: ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
        ) -> Self {
            self.field_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        ///
        /// The builder fails to construct a [`ValidationException`](crate::error::ValidationException) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::ValidationException, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ValidationException, ConstraintViolation> {
            Ok(crate::error::ValidationException {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
                field_list: self.field_list,
            })
        }
    }
}
