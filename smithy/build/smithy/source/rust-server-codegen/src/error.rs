// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `QueryDataset` operation.
/// Each variant represents an error that can occur for the `QueryDataset` operation.
#[derive(::std::fmt::Debug)]
pub enum QueryDatasetError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    /// Throttling error.
    ThrottlingError(crate::error::ThrottlingError),
    /// Server error.
    ServerError(crate::error::ServerError),
}
impl ::std::fmt::Display for QueryDatasetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            QueryDatasetError::ValidationException(_inner) => _inner.fmt(f),
            QueryDatasetError::ThrottlingError(_inner) => _inner.fmt(f),
            QueryDatasetError::ServerError(_inner) => _inner.fmt(f),
        }
    }
}
impl QueryDatasetError {
    /// Returns `true` if the error kind is `QueryDatasetError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, QueryDatasetError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `QueryDatasetError::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self, QueryDatasetError::ThrottlingError(_))
    }
    /// Returns `true` if the error kind is `QueryDatasetError::ServerError`.
    pub fn is_server_error(&self) -> bool {
        matches!(&self, QueryDatasetError::ServerError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            QueryDatasetError::ValidationException(_inner) => _inner.name(),
            QueryDatasetError::ThrottlingError(_inner) => _inner.name(),
            QueryDatasetError::ServerError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for QueryDatasetError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            QueryDatasetError::ValidationException(_inner) => Some(_inner),
            QueryDatasetError::ThrottlingError(_inner) => Some(_inner),
            QueryDatasetError::ServerError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::QueryDatasetError {
    fn from(variant: crate::error::ValidationException) -> crate::error::QueryDatasetError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::ThrottlingError> for crate::error::QueryDatasetError {
    fn from(variant: crate::error::ThrottlingError) -> crate::error::QueryDatasetError {
        Self::ThrottlingError(variant)
    }
}
impl ::std::convert::From<crate::error::ServerError> for crate::error::QueryDatasetError {
    fn from(variant: crate::error::ServerError) -> crate::error::QueryDatasetError {
        Self::ServerError(variant)
    }
}

/// Server error.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ServerError {
    #[allow(missing_docs)] // documentation missing in model
    pub code: crate::model::ErrorCode,
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl ServerError {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> &crate::model::ErrorCode {
        &self.code
    }
}
impl ServerError {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ServerError"
    }
}
impl ::std::fmt::Display for ServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ServerError")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ServerError {}
impl ServerError {
    /// Creates a new builder-style object to manufacture [`ServerError`](crate::error::ServerError).
    pub fn builder() -> crate::error::server_error::Builder {
        crate::error::server_error::Builder::default()
    }
}

/// Throttling error.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ThrottlingError {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl ThrottlingError {
    /// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
    pub fn retryable_error_kind(&self) -> ::aws_smithy_types::retry::ErrorKind {
        ::aws_smithy_types::retry::ErrorKind::ClientError
    }
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ThrottlingError"
    }
}
impl ::std::fmt::Display for ThrottlingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ThrottlingError")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ThrottlingError {}
impl ThrottlingError {
    /// Creates a new builder-style object to manufacture [`ThrottlingError`](crate::error::ThrottlingError).
    pub fn builder() -> crate::error::throttling_error::Builder {
        crate::error::throttling_error::Builder::default()
    }
}

/// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ValidationException {
    /// A summary of the validation failure.
    pub message: ::std::string::String,
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub field_list: ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
}
impl ValidationException {
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub fn field_list(&self) -> ::std::option::Option<&[crate::model::ValidationExceptionField]> {
        self.field_list.as_deref()
    }
}
impl ValidationException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ValidationException"
    }
}
impl ::std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ValidationException")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ValidationException {}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// Error type for the `GetDataset` operation.
/// Each variant represents an error that can occur for the `GetDataset` operation.
#[derive(::std::fmt::Debug)]
pub enum GetDatasetError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    /// Not found error.
    NotFoundError(crate::error::NotFoundError),
    /// Throttling error.
    ThrottlingError(crate::error::ThrottlingError),
    /// Server error.
    ServerError(crate::error::ServerError),
}
impl ::std::fmt::Display for GetDatasetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            GetDatasetError::ValidationException(_inner) => _inner.fmt(f),
            GetDatasetError::NotFoundError(_inner) => _inner.fmt(f),
            GetDatasetError::ThrottlingError(_inner) => _inner.fmt(f),
            GetDatasetError::ServerError(_inner) => _inner.fmt(f),
        }
    }
}
impl GetDatasetError {
    /// Returns `true` if the error kind is `GetDatasetError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, GetDatasetError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `GetDatasetError::NotFoundError`.
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self, GetDatasetError::NotFoundError(_))
    }
    /// Returns `true` if the error kind is `GetDatasetError::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self, GetDatasetError::ThrottlingError(_))
    }
    /// Returns `true` if the error kind is `GetDatasetError::ServerError`.
    pub fn is_server_error(&self) -> bool {
        matches!(&self, GetDatasetError::ServerError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            GetDatasetError::ValidationException(_inner) => _inner.name(),
            GetDatasetError::NotFoundError(_inner) => _inner.name(),
            GetDatasetError::ThrottlingError(_inner) => _inner.name(),
            GetDatasetError::ServerError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for GetDatasetError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            GetDatasetError::ValidationException(_inner) => Some(_inner),
            GetDatasetError::NotFoundError(_inner) => Some(_inner),
            GetDatasetError::ThrottlingError(_inner) => Some(_inner),
            GetDatasetError::ServerError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::GetDatasetError {
    fn from(variant: crate::error::ValidationException) -> crate::error::GetDatasetError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::NotFoundError> for crate::error::GetDatasetError {
    fn from(variant: crate::error::NotFoundError) -> crate::error::GetDatasetError {
        Self::NotFoundError(variant)
    }
}
impl ::std::convert::From<crate::error::ThrottlingError> for crate::error::GetDatasetError {
    fn from(variant: crate::error::ThrottlingError) -> crate::error::GetDatasetError {
        Self::ThrottlingError(variant)
    }
}
impl ::std::convert::From<crate::error::ServerError> for crate::error::GetDatasetError {
    fn from(variant: crate::error::ServerError) -> crate::error::GetDatasetError {
        Self::ServerError(variant)
    }
}

/// Not found error.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct NotFoundError {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl NotFoundError {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "NotFoundError"
    }
}
impl ::std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "NotFoundError")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for NotFoundError {}
impl NotFoundError {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError).
    pub fn builder() -> crate::error::not_found_error::Builder {
        crate::error::not_found_error::Builder::default()
    }
}

/// Error type for the `CreateDataset` operation.
/// Each variant represents an error that can occur for the `CreateDataset` operation.
#[derive(::std::fmt::Debug)]
pub enum CreateDatasetError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    /// Throttling error.
    ThrottlingError(crate::error::ThrottlingError),
    /// Server error.
    ServerError(crate::error::ServerError),
}
impl ::std::fmt::Display for CreateDatasetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            CreateDatasetError::ValidationException(_inner) => _inner.fmt(f),
            CreateDatasetError::ThrottlingError(_inner) => _inner.fmt(f),
            CreateDatasetError::ServerError(_inner) => _inner.fmt(f),
        }
    }
}
impl CreateDatasetError {
    /// Returns `true` if the error kind is `CreateDatasetError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, CreateDatasetError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `CreateDatasetError::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self, CreateDatasetError::ThrottlingError(_))
    }
    /// Returns `true` if the error kind is `CreateDatasetError::ServerError`.
    pub fn is_server_error(&self) -> bool {
        matches!(&self, CreateDatasetError::ServerError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            CreateDatasetError::ValidationException(_inner) => _inner.name(),
            CreateDatasetError::ThrottlingError(_inner) => _inner.name(),
            CreateDatasetError::ServerError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for CreateDatasetError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            CreateDatasetError::ValidationException(_inner) => Some(_inner),
            CreateDatasetError::ThrottlingError(_inner) => Some(_inner),
            CreateDatasetError::ServerError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::CreateDatasetError {
    fn from(variant: crate::error::ValidationException) -> crate::error::CreateDatasetError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::ThrottlingError> for crate::error::CreateDatasetError {
    fn from(variant: crate::error::ThrottlingError) -> crate::error::CreateDatasetError {
        Self::ThrottlingError(variant)
    }
}
impl ::std::convert::From<crate::error::ServerError> for crate::error::CreateDatasetError {
    fn from(variant: crate::error::ServerError) -> crate::error::CreateDatasetError {
        Self::ServerError(variant)
    }
}

/// Error type for the `ListDataset` operation.
/// Each variant represents an error that can occur for the `ListDataset` operation.
#[derive(::std::fmt::Debug)]
pub enum ListDatasetError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    /// Throttling error.
    ThrottlingError(crate::error::ThrottlingError),
    /// Server error.
    ServerError(crate::error::ServerError),
}
impl ::std::fmt::Display for ListDatasetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            ListDatasetError::ValidationException(_inner) => _inner.fmt(f),
            ListDatasetError::ThrottlingError(_inner) => _inner.fmt(f),
            ListDatasetError::ServerError(_inner) => _inner.fmt(f),
        }
    }
}
impl ListDatasetError {
    /// Returns `true` if the error kind is `ListDatasetError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, ListDatasetError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `ListDatasetError::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self, ListDatasetError::ThrottlingError(_))
    }
    /// Returns `true` if the error kind is `ListDatasetError::ServerError`.
    pub fn is_server_error(&self) -> bool {
        matches!(&self, ListDatasetError::ServerError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            ListDatasetError::ValidationException(_inner) => _inner.name(),
            ListDatasetError::ThrottlingError(_inner) => _inner.name(),
            ListDatasetError::ServerError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for ListDatasetError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            ListDatasetError::ValidationException(_inner) => Some(_inner),
            ListDatasetError::ThrottlingError(_inner) => Some(_inner),
            ListDatasetError::ServerError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::ListDatasetError {
    fn from(variant: crate::error::ValidationException) -> crate::error::ListDatasetError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::ThrottlingError> for crate::error::ListDatasetError {
    fn from(variant: crate::error::ThrottlingError) -> crate::error::ListDatasetError {
        Self::ThrottlingError(variant)
    }
}
impl ::std::convert::From<crate::error::ServerError> for crate::error::ListDatasetError {
    fn from(variant: crate::error::ServerError) -> crate::error::ListDatasetError {
        Self::ServerError(variant)
    }
}

/// Error type for the `Signin` operation.
/// Each variant represents an error that can occur for the `Signin` operation.
#[derive(::std::fmt::Debug)]
pub enum SigninError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    /// Unauthorized error.
    UnauthorizedError(crate::error::UnauthorizedError),
    /// Forbidden error.
    ForbiddenError(crate::error::ForbiddenError),
    /// Throttling error.
    ThrottlingError(crate::error::ThrottlingError),
}
impl ::std::fmt::Display for SigninError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            SigninError::ValidationException(_inner) => _inner.fmt(f),
            SigninError::UnauthorizedError(_inner) => _inner.fmt(f),
            SigninError::ForbiddenError(_inner) => _inner.fmt(f),
            SigninError::ThrottlingError(_inner) => _inner.fmt(f),
        }
    }
}
impl SigninError {
    /// Returns `true` if the error kind is `SigninError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, SigninError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `SigninError::UnauthorizedError`.
    pub fn is_unauthorized_error(&self) -> bool {
        matches!(&self, SigninError::UnauthorizedError(_))
    }
    /// Returns `true` if the error kind is `SigninError::ForbiddenError`.
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self, SigninError::ForbiddenError(_))
    }
    /// Returns `true` if the error kind is `SigninError::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self, SigninError::ThrottlingError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            SigninError::ValidationException(_inner) => _inner.name(),
            SigninError::UnauthorizedError(_inner) => _inner.name(),
            SigninError::ForbiddenError(_inner) => _inner.name(),
            SigninError::ThrottlingError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for SigninError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            SigninError::ValidationException(_inner) => Some(_inner),
            SigninError::UnauthorizedError(_inner) => Some(_inner),
            SigninError::ForbiddenError(_inner) => Some(_inner),
            SigninError::ThrottlingError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::SigninError {
    fn from(variant: crate::error::ValidationException) -> crate::error::SigninError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::UnauthorizedError> for crate::error::SigninError {
    fn from(variant: crate::error::UnauthorizedError) -> crate::error::SigninError {
        Self::UnauthorizedError(variant)
    }
}
impl ::std::convert::From<crate::error::ForbiddenError> for crate::error::SigninError {
    fn from(variant: crate::error::ForbiddenError) -> crate::error::SigninError {
        Self::ForbiddenError(variant)
    }
}
impl ::std::convert::From<crate::error::ThrottlingError> for crate::error::SigninError {
    fn from(variant: crate::error::ThrottlingError) -> crate::error::SigninError {
        Self::ThrottlingError(variant)
    }
}

/// Forbidden error.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ForbiddenError {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl ForbiddenError {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ForbiddenError"
    }
}
impl ::std::fmt::Display for ForbiddenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ForbiddenError")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ForbiddenError {}
impl ForbiddenError {
    /// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError).
    pub fn builder() -> crate::error::forbidden_error::Builder {
        crate::error::forbidden_error::Builder::default()
    }
}

/// Unauthorized error.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct UnauthorizedError {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl UnauthorizedError {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "UnauthorizedError"
    }
}
impl ::std::fmt::Display for UnauthorizedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "UnauthorizedError")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for UnauthorizedError {}
impl UnauthorizedError {
    /// Creates a new builder-style object to manufacture [`UnauthorizedError`](crate::error::UnauthorizedError).
    pub fn builder() -> crate::error::unauthorized_error::Builder {
        crate::error::unauthorized_error::Builder::default()
    }
}

/// Error type for the `HealthCheck` operation.
/// Each variant represents an error that can occur for the `HealthCheck` operation.
#[derive(::std::fmt::Debug)]
pub enum HealthCheckError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    /// Server error.
    ServerError(crate::error::ServerError),
}
impl ::std::fmt::Display for HealthCheckError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            HealthCheckError::ValidationException(_inner) => _inner.fmt(f),
            HealthCheckError::ServerError(_inner) => _inner.fmt(f),
        }
    }
}
impl HealthCheckError {
    /// Returns `true` if the error kind is `HealthCheckError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, HealthCheckError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `HealthCheckError::ServerError`.
    pub fn is_server_error(&self) -> bool {
        matches!(&self, HealthCheckError::ServerError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            HealthCheckError::ValidationException(_inner) => _inner.name(),
            HealthCheckError::ServerError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for HealthCheckError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            HealthCheckError::ValidationException(_inner) => Some(_inner),
            HealthCheckError::ServerError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::HealthCheckError {
    fn from(variant: crate::error::ValidationException) -> crate::error::HealthCheckError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::ServerError> for crate::error::HealthCheckError {
    fn from(variant: crate::error::ServerError) -> crate::error::HealthCheckError {
        Self::ServerError(variant)
    }
}
/// See [`ServerError`](crate::error::ServerError).
///
pub mod server_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `code` was not provided but it is required when building `ServerError`.
        MissingCode,
        /// `message` was not provided but it is required when building `ServerError`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingCode => write!(
                    f,
                    "`code` was not provided but it is required when building `ServerError`"
                ),
                ConstraintViolation::MissingMessage => write!(
                    f,
                    "`message` was not provided but it is required when building `ServerError`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ServerError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ServerError`](crate::error::ServerError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: ::std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`ServerError`](crate::error::ServerError).
        ///
        /// The builder fails to construct a [`ServerError`](crate::error::ServerError) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::error::ServerError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ServerError, ConstraintViolation> {
            Ok(crate::error::ServerError {
                code: self.code.ok_or(ConstraintViolation::MissingCode)?,
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`ThrottlingError`](crate::error::ThrottlingError).
///
pub mod throttling_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ThrottlingError`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(
                    f,
                    "`message` was not provided but it is required when building `ThrottlingError`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ThrottlingError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ThrottlingError`](crate::error::ThrottlingError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingError`](crate::error::ThrottlingError).
        ///
        /// The builder fails to construct a [`ThrottlingError`](crate::error::ThrottlingError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::ThrottlingError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ThrottlingError, ConstraintViolation> {
            Ok(crate::error::ThrottlingError {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`ValidationException`](crate::error::ValidationException).
///
pub mod validation_exception {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ValidationException`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `ValidationException`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ValidationException {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
        pub(crate) field_list:
            ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
    }
    impl Builder {
        /// A summary of the validation failure.
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
        pub fn field_list(
            mut self,
            input: ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
        ) -> Self {
            self.field_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        ///
        /// The builder fails to construct a [`ValidationException`](crate::error::ValidationException) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::ValidationException, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ValidationException, ConstraintViolation> {
            Ok(crate::error::ValidationException {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
                field_list: self.field_list,
            })
        }
    }
}
/// See [`NotFoundError`](crate::error::NotFoundError).
///
pub mod not_found_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `NotFoundError`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(
                    f,
                    "`message` was not provided but it is required when building `NotFoundError`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::NotFoundError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`NotFoundError`](crate::error::NotFoundError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError).
        ///
        /// The builder fails to construct a [`NotFoundError`](crate::error::NotFoundError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::NotFoundError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::NotFoundError, ConstraintViolation> {
            Ok(crate::error::NotFoundError {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`ForbiddenError`](crate::error::ForbiddenError).
///
pub mod forbidden_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ForbiddenError`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(
                    f,
                    "`message` was not provided but it is required when building `ForbiddenError`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ForbiddenError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ForbiddenError`](crate::error::ForbiddenError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError).
        ///
        /// The builder fails to construct a [`ForbiddenError`](crate::error::ForbiddenError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::ForbiddenError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ForbiddenError, ConstraintViolation> {
            Ok(crate::error::ForbiddenError {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`UnauthorizedError`](crate::error::UnauthorizedError).
///
pub mod unauthorized_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `UnauthorizedError`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `UnauthorizedError`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::UnauthorizedError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`UnauthorizedError`](crate::error::UnauthorizedError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedError`](crate::error::UnauthorizedError).
        ///
        /// The builder fails to construct a [`UnauthorizedError`](crate::error::UnauthorizedError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::UnauthorizedError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::UnauthorizedError, ConstraintViolation> {
            Ok(crate::error::UnauthorizedError {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
